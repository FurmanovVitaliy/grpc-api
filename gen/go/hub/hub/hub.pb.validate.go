// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: hub/hub.proto

package furmanov_hub_v1_proto

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// define the regex for a UUID once up-front
var _hub_uuidPattern = regexp.MustCompile("^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$")

// Validate checks the field values on SessionDescription with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SessionDescription) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SessionDescription with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SessionDescriptionMultiError, or nil if none found.
func (m *SessionDescription) ValidateAll() error {
	return m.validate(true)
}

func (m *SessionDescription) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Sdp

	// no validation rules for Type

	if len(errors) > 0 {
		return SessionDescriptionMultiError(errors)
	}

	return nil
}

// SessionDescriptionMultiError is an error wrapping multiple validation errors
// returned by SessionDescription.ValidateAll() if the designated constraints
// aren't met.
type SessionDescriptionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SessionDescriptionMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SessionDescriptionMultiError) AllErrors() []error { return m }

// SessionDescriptionValidationError is the validation error returned by
// SessionDescription.Validate if the designated constraints aren't met.
type SessionDescriptionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SessionDescriptionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SessionDescriptionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SessionDescriptionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SessionDescriptionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SessionDescriptionValidationError) ErrorName() string {
	return "SessionDescriptionValidationError"
}

// Error satisfies the builtin error interface
func (e SessionDescriptionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSessionDescription.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SessionDescriptionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SessionDescriptionValidationError{}

// Validate checks the field values on IceCandidate with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *IceCandidate) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on IceCandidate with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in IceCandidateMultiError, or
// nil if none found.
func (m *IceCandidate) ValidateAll() error {
	return m.validate(true)
}

func (m *IceCandidate) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Candidate

	// no validation rules for SdpMid

	// no validation rules for SdpMlineIndex

	if len(errors) > 0 {
		return IceCandidateMultiError(errors)
	}

	return nil
}

// IceCandidateMultiError is an error wrapping multiple validation errors
// returned by IceCandidate.ValidateAll() if the designated constraints aren't met.
type IceCandidateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IceCandidateMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IceCandidateMultiError) AllErrors() []error { return m }

// IceCandidateValidationError is the validation error returned by
// IceCandidate.Validate if the designated constraints aren't met.
type IceCandidateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IceCandidateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IceCandidateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IceCandidateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IceCandidateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IceCandidateValidationError) ErrorName() string { return "IceCandidateValidationError" }

// Error satisfies the builtin error interface
func (e IceCandidateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIceCandidate.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IceCandidateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IceCandidateValidationError{}

// Validate checks the field values on GameInfo with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GameInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GameInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GameInfoMultiError, or nil
// if none found.
func (m *GameInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *GameInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if err := m._validateUuid(m.GetId()); err != nil {
		err = GameInfoValidationError{
			field:  "Id",
			reason: "value must be a valid UUID",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetName()) < 1 {
		err := GameInfoValidationError{
			field:  "Name",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetUrl()) < 1 {
		err := GameInfoValidationError{
			field:  "Url",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetPosterUrl()) < 1 {
		err := GameInfoValidationError{
			field:  "PosterUrl",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetPlatform()) < 1 {
		err := GameInfoValidationError{
			field:  "Platform",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Rating

	if utf8.RuneCountInString(m.GetSummary()) < 1 {
		err := GameInfoValidationError{
			field:  "Summary",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetReleaseDate() < 0 {
		err := GameInfoValidationError{
			field:  "ReleaseDate",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetAgeRating()) < 1 {
		err := GameInfoValidationError{
			field:  "AgeRating",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetPublisher()) < 1 {
		err := GameInfoValidationError{
			field:  "Publisher",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetDeveloper()) < 1 {
		err := GameInfoValidationError{
			field:  "Developer",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GameInfoMultiError(errors)
	}

	return nil
}

func (m *GameInfo) _validateUuid(uuid string) error {
	if matched := _hub_uuidPattern.MatchString(uuid); !matched {
		return errors.New("invalid uuid format")
	}

	return nil
}

// GameInfoMultiError is an error wrapping multiple validation errors returned
// by GameInfo.ValidateAll() if the designated constraints aren't met.
type GameInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GameInfoMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GameInfoMultiError) AllErrors() []error { return m }

// GameInfoValidationError is the validation error returned by
// GameInfo.Validate if the designated constraints aren't met.
type GameInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GameInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GameInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GameInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GameInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GameInfoValidationError) ErrorName() string { return "GameInfoValidationError" }

// Error satisfies the builtin error interface
func (e GameInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGameInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GameInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GameInfoValidationError{}

// Validate checks the field values on PlayerEnv with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PlayerEnv) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PlayerEnv with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PlayerEnvMultiError, or nil
// if none found.
func (m *PlayerEnv) ValidateAll() error {
	return m.validate(true)
}

func (m *PlayerEnv) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Platform

	// no validation rules for DisplayWidth

	// no validation rules for DisplayHeight

	// no validation rules for InputType

	// no validation rules for InputVendor

	// no validation rules for InputProduct

	if len(errors) > 0 {
		return PlayerEnvMultiError(errors)
	}

	return nil
}

// PlayerEnvMultiError is an error wrapping multiple validation errors returned
// by PlayerEnv.ValidateAll() if the designated constraints aren't met.
type PlayerEnvMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PlayerEnvMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PlayerEnvMultiError) AllErrors() []error { return m }

// PlayerEnvValidationError is the validation error returned by
// PlayerEnv.Validate if the designated constraints aren't met.
type PlayerEnvValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PlayerEnvValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PlayerEnvValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PlayerEnvValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PlayerEnvValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PlayerEnvValidationError) ErrorName() string { return "PlayerEnvValidationError" }

// Error satisfies the builtin error interface
func (e PlayerEnvValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPlayerEnv.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PlayerEnvValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PlayerEnvValidationError{}

// Validate checks the field values on GamesLibraryRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GamesLibraryRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GamesLibraryRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GamesLibraryRequestMultiError, or nil if none found.
func (m *GamesLibraryRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GamesLibraryRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return GamesLibraryRequestMultiError(errors)
	}

	return nil
}

// GamesLibraryRequestMultiError is an error wrapping multiple validation
// errors returned by GamesLibraryRequest.ValidateAll() if the designated
// constraints aren't met.
type GamesLibraryRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GamesLibraryRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GamesLibraryRequestMultiError) AllErrors() []error { return m }

// GamesLibraryRequestValidationError is the validation error returned by
// GamesLibraryRequest.Validate if the designated constraints aren't met.
type GamesLibraryRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GamesLibraryRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GamesLibraryRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GamesLibraryRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GamesLibraryRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GamesLibraryRequestValidationError) ErrorName() string {
	return "GamesLibraryRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GamesLibraryRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGamesLibraryRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GamesLibraryRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GamesLibraryRequestValidationError{}

// Validate checks the field values on GamesLibraryResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GamesLibraryResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GamesLibraryResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GamesLibraryResponseMultiError, or nil if none found.
func (m *GamesLibraryResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GamesLibraryResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetGames() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GamesLibraryResponseValidationError{
						field:  fmt.Sprintf("Games[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GamesLibraryResponseValidationError{
						field:  fmt.Sprintf("Games[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GamesLibraryResponseValidationError{
					field:  fmt.Sprintf("Games[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GamesLibraryResponseMultiError(errors)
	}

	return nil
}

// GamesLibraryResponseMultiError is an error wrapping multiple validation
// errors returned by GamesLibraryResponse.ValidateAll() if the designated
// constraints aren't met.
type GamesLibraryResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GamesLibraryResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GamesLibraryResponseMultiError) AllErrors() []error { return m }

// GamesLibraryResponseValidationError is the validation error returned by
// GamesLibraryResponse.Validate if the designated constraints aren't met.
type GamesLibraryResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GamesLibraryResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GamesLibraryResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GamesLibraryResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GamesLibraryResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GamesLibraryResponseValidationError) ErrorName() string {
	return "GamesLibraryResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GamesLibraryResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGamesLibraryResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GamesLibraryResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GamesLibraryResponseValidationError{}

// Validate checks the field values on GameInfoRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GameInfoRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GameInfoRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GameInfoRequestMultiError, or nil if none found.
func (m *GameInfoRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GameInfoRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if err := m._validateUuid(m.GetId()); err != nil {
		err = GameInfoRequestValidationError{
			field:  "Id",
			reason: "value must be a valid UUID",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GameInfoRequestMultiError(errors)
	}

	return nil
}

func (m *GameInfoRequest) _validateUuid(uuid string) error {
	if matched := _hub_uuidPattern.MatchString(uuid); !matched {
		return errors.New("invalid uuid format")
	}

	return nil
}

// GameInfoRequestMultiError is an error wrapping multiple validation errors
// returned by GameInfoRequest.ValidateAll() if the designated constraints
// aren't met.
type GameInfoRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GameInfoRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GameInfoRequestMultiError) AllErrors() []error { return m }

// GameInfoRequestValidationError is the validation error returned by
// GameInfoRequest.Validate if the designated constraints aren't met.
type GameInfoRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GameInfoRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GameInfoRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GameInfoRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GameInfoRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GameInfoRequestValidationError) ErrorName() string { return "GameInfoRequestValidationError" }

// Error satisfies the builtin error interface
func (e GameInfoRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGameInfoRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GameInfoRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GameInfoRequestValidationError{}

// Validate checks the field values on GameInfoResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GameInfoResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GameInfoResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GameInfoResponseMultiError, or nil if none found.
func (m *GameInfoResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GameInfoResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetGame()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GameInfoResponseValidationError{
					field:  "Game",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GameInfoResponseValidationError{
					field:  "Game",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGame()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GameInfoResponseValidationError{
				field:  "Game",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GameInfoResponseMultiError(errors)
	}

	return nil
}

// GameInfoResponseMultiError is an error wrapping multiple validation errors
// returned by GameInfoResponse.ValidateAll() if the designated constraints
// aren't met.
type GameInfoResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GameInfoResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GameInfoResponseMultiError) AllErrors() []error { return m }

// GameInfoResponseValidationError is the validation error returned by
// GameInfoResponse.Validate if the designated constraints aren't met.
type GameInfoResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GameInfoResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GameInfoResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GameInfoResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GameInfoResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GameInfoResponseValidationError) ErrorName() string { return "GameInfoResponseValidationError" }

// Error satisfies the builtin error interface
func (e GameInfoResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGameInfoResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GameInfoResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GameInfoResponseValidationError{}

// Validate checks the field values on BindPlayerRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *BindPlayerRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BindPlayerRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BindPlayerRequestMultiError, or nil if none found.
func (m *BindPlayerRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *BindPlayerRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetUsername()); l < 3 || l > 50 {
		err := BindPlayerRequestValidationError{
			field:  "Username",
			reason: "value length must be between 3 and 50 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_BindPlayerRequest_Username_Pattern.MatchString(m.GetUsername()) {
		err := BindPlayerRequestValidationError{
			field:  "Username",
			reason: "value does not match regex pattern \"^[a-zA-Z0-9_]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetPlayerEnv()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BindPlayerRequestValidationError{
					field:  "PlayerEnv",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BindPlayerRequestValidationError{
					field:  "PlayerEnv",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPlayerEnv()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BindPlayerRequestValidationError{
				field:  "PlayerEnv",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if utf8.RuneCountInString(m.GetAccessToken()) < 1 {
		err := BindPlayerRequestValidationError{
			field:  "AccessToken",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return BindPlayerRequestMultiError(errors)
	}

	return nil
}

// BindPlayerRequestMultiError is an error wrapping multiple validation errors
// returned by BindPlayerRequest.ValidateAll() if the designated constraints
// aren't met.
type BindPlayerRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BindPlayerRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BindPlayerRequestMultiError) AllErrors() []error { return m }

// BindPlayerRequestValidationError is the validation error returned by
// BindPlayerRequest.Validate if the designated constraints aren't met.
type BindPlayerRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BindPlayerRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BindPlayerRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BindPlayerRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BindPlayerRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BindPlayerRequestValidationError) ErrorName() string {
	return "BindPlayerRequestValidationError"
}

// Error satisfies the builtin error interface
func (e BindPlayerRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBindPlayerRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BindPlayerRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BindPlayerRequestValidationError{}

var _BindPlayerRequest_Username_Pattern = regexp.MustCompile("^[a-zA-Z0-9_]+$")

// Validate checks the field values on BindPlayerResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BindPlayerResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BindPlayerResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BindPlayerResponseMultiError, or nil if none found.
func (m *BindPlayerResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *BindPlayerResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Success

	if len(errors) > 0 {
		return BindPlayerResponseMultiError(errors)
	}

	return nil
}

// BindPlayerResponseMultiError is an error wrapping multiple validation errors
// returned by BindPlayerResponse.ValidateAll() if the designated constraints
// aren't met.
type BindPlayerResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BindPlayerResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BindPlayerResponseMultiError) AllErrors() []error { return m }

// BindPlayerResponseValidationError is the validation error returned by
// BindPlayerResponse.Validate if the designated constraints aren't met.
type BindPlayerResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BindPlayerResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BindPlayerResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BindPlayerResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BindPlayerResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BindPlayerResponseValidationError) ErrorName() string {
	return "BindPlayerResponseValidationError"
}

// Error satisfies the builtin error interface
func (e BindPlayerResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBindPlayerResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BindPlayerResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BindPlayerResponseValidationError{}

// Validate checks the field values on WebRTCSignalingMessage with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *WebRTCSignalingMessage) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WebRTCSignalingMessage with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// WebRTCSignalingMessageMultiError, or nil if none found.
func (m *WebRTCSignalingMessage) ValidateAll() error {
	return m.validate(true)
}

func (m *WebRTCSignalingMessage) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SessionId

	// no validation rules for Type

	switch v := m.Payload.(type) {
	case *WebRTCSignalingMessage_Description:
		if v == nil {
			err := WebRTCSignalingMessageValidationError{
				field:  "Payload",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetDescription()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, WebRTCSignalingMessageValidationError{
						field:  "Description",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, WebRTCSignalingMessageValidationError{
						field:  "Description",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDescription()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return WebRTCSignalingMessageValidationError{
					field:  "Description",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *WebRTCSignalingMessage_Candidate:
		if v == nil {
			err := WebRTCSignalingMessageValidationError{
				field:  "Payload",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetCandidate()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, WebRTCSignalingMessageValidationError{
						field:  "Candidate",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, WebRTCSignalingMessageValidationError{
						field:  "Candidate",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCandidate()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return WebRTCSignalingMessageValidationError{
					field:  "Candidate",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *WebRTCSignalingMessage_Error:
		if v == nil {
			err := WebRTCSignalingMessageValidationError{
				field:  "Payload",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for Error
	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return WebRTCSignalingMessageMultiError(errors)
	}

	return nil
}

// WebRTCSignalingMessageMultiError is an error wrapping multiple validation
// errors returned by WebRTCSignalingMessage.ValidateAll() if the designated
// constraints aren't met.
type WebRTCSignalingMessageMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WebRTCSignalingMessageMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WebRTCSignalingMessageMultiError) AllErrors() []error { return m }

// WebRTCSignalingMessageValidationError is the validation error returned by
// WebRTCSignalingMessage.Validate if the designated constraints aren't met.
type WebRTCSignalingMessageValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WebRTCSignalingMessageValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WebRTCSignalingMessageValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WebRTCSignalingMessageValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WebRTCSignalingMessageValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WebRTCSignalingMessageValidationError) ErrorName() string {
	return "WebRTCSignalingMessageValidationError"
}

// Error satisfies the builtin error interface
func (e WebRTCSignalingMessageValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWebRTCSignalingMessage.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WebRTCSignalingMessageValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WebRTCSignalingMessageValidationError{}

// Validate checks the field values on SystemLoad with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SystemLoad) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SystemLoad with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SystemLoadMultiError, or
// nil if none found.
func (m *SystemLoad) ValidateAll() error {
	return m.validate(true)
}

func (m *SystemLoad) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Cpu

	// no validation rules for Memory

	// no validation rules for Gpu

	// no validation rules for Network

	// no validation rules for PlayerSlots

	if len(errors) > 0 {
		return SystemLoadMultiError(errors)
	}

	return nil
}

// SystemLoadMultiError is an error wrapping multiple validation errors
// returned by SystemLoad.ValidateAll() if the designated constraints aren't met.
type SystemLoadMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SystemLoadMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SystemLoadMultiError) AllErrors() []error { return m }

// SystemLoadValidationError is the validation error returned by
// SystemLoad.Validate if the designated constraints aren't met.
type SystemLoadValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SystemLoadValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SystemLoadValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SystemLoadValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SystemLoadValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SystemLoadValidationError) ErrorName() string { return "SystemLoadValidationError" }

// Error satisfies the builtin error interface
func (e SystemLoadValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSystemLoad.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SystemLoadValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SystemLoadValidationError{}

// Validate checks the field values on GamesWithHash with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GamesWithHash) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GamesWithHash with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GamesWithHashMultiError, or
// nil if none found.
func (m *GamesWithHash) ValidateAll() error {
	return m.validate(true)
}

func (m *GamesWithHash) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetGames() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GamesWithHashValidationError{
						field:  fmt.Sprintf("Games[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GamesWithHashValidationError{
						field:  fmt.Sprintf("Games[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GamesWithHashValidationError{
					field:  fmt.Sprintf("Games[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for GamesHash

	if len(errors) > 0 {
		return GamesWithHashMultiError(errors)
	}

	return nil
}

// GamesWithHashMultiError is an error wrapping multiple validation errors
// returned by GamesWithHash.ValidateAll() if the designated constraints
// aren't met.
type GamesWithHashMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GamesWithHashMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GamesWithHashMultiError) AllErrors() []error { return m }

// GamesWithHashValidationError is the validation error returned by
// GamesWithHash.Validate if the designated constraints aren't met.
type GamesWithHashValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GamesWithHashValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GamesWithHashValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GamesWithHashValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GamesWithHashValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GamesWithHashValidationError) ErrorName() string { return "GamesWithHashValidationError" }

// Error satisfies the builtin error interface
func (e GamesWithHashValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGamesWithHash.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GamesWithHashValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GamesWithHashValidationError{}

// Validate checks the field values on GeoData with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GeoData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GeoData with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in GeoDataMultiError, or nil if none found.
func (m *GeoData) ValidateAll() error {
	return m.validate(true)
}

func (m *GeoData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Country

	// no validation rules for Region

	// no validation rules for City

	// no validation rules for Latitude

	// no validation rules for Longitude

	// no validation rules for Timezone

	if len(errors) > 0 {
		return GeoDataMultiError(errors)
	}

	return nil
}

// GeoDataMultiError is an error wrapping multiple validation errors returned
// by GeoData.ValidateAll() if the designated constraints aren't met.
type GeoDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GeoDataMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GeoDataMultiError) AllErrors() []error { return m }

// GeoDataValidationError is the validation error returned by GeoData.Validate
// if the designated constraints aren't met.
type GeoDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GeoDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GeoDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GeoDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GeoDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GeoDataValidationError) ErrorName() string { return "GeoDataValidationError" }

// Error satisfies the builtin error interface
func (e GeoDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGeoData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GeoDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GeoDataValidationError{}

// Validate checks the field values on Station with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Station) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Station with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in StationMultiError, or nil if none found.
func (m *Station) ValidateAll() error {
	return m.validate(true)
}

func (m *Station) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Ip

	// no validation rules for Port

	if all {
		switch v := interface{}(m.GetGeoData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, StationValidationError{
					field:  "GeoData",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, StationValidationError{
					field:  "GeoData",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGeoData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return StationValidationError{
				field:  "GeoData",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return StationMultiError(errors)
	}

	return nil
}

// StationMultiError is an error wrapping multiple validation errors returned
// by Station.ValidateAll() if the designated constraints aren't met.
type StationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StationMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StationMultiError) AllErrors() []error { return m }

// StationValidationError is the validation error returned by Station.Validate
// if the designated constraints aren't met.
type StationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StationValidationError) ErrorName() string { return "StationValidationError" }

// Error satisfies the builtin error interface
func (e StationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStation.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StationValidationError{}

// Validate checks the field values on CommandMessage with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CommandMessage) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CommandMessage with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CommandMessageMultiError,
// or nil if none found.
func (m *CommandMessage) ValidateAll() error {
	return m.validate(true)
}

func (m *CommandMessage) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TaskId

	switch v := m.Command.(type) {
	case *CommandMessage_Start:
		if v == nil {
			err := CommandMessageValidationError{
				field:  "Command",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetStart()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CommandMessageValidationError{
						field:  "Start",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CommandMessageValidationError{
						field:  "Start",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetStart()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CommandMessageValidationError{
					field:  "Start",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *CommandMessage_Stop:
		if v == nil {
			err := CommandMessageValidationError{
				field:  "Command",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetStop()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CommandMessageValidationError{
						field:  "Stop",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CommandMessageValidationError{
						field:  "Stop",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetStop()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CommandMessageValidationError{
					field:  "Stop",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *CommandMessage_Error:
		if v == nil {
			err := CommandMessageValidationError{
				field:  "Command",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetError()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CommandMessageValidationError{
						field:  "Error",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CommandMessageValidationError{
						field:  "Error",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetError()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CommandMessageValidationError{
					field:  "Error",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return CommandMessageMultiError(errors)
	}

	return nil
}

// CommandMessageMultiError is an error wrapping multiple validation errors
// returned by CommandMessage.ValidateAll() if the designated constraints
// aren't met.
type CommandMessageMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CommandMessageMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CommandMessageMultiError) AllErrors() []error { return m }

// CommandMessageValidationError is the validation error returned by
// CommandMessage.Validate if the designated constraints aren't met.
type CommandMessageValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CommandMessageValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CommandMessageValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CommandMessageValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CommandMessageValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CommandMessageValidationError) ErrorName() string { return "CommandMessageValidationError" }

// Error satisfies the builtin error interface
func (e CommandMessageValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCommandMessage.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CommandMessageValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CommandMessageValidationError{}

// Validate checks the field values on StartPlaySession with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *StartPlaySession) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StartPlaySession with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// StartPlaySessionMultiError, or nil if none found.
func (m *StartPlaySession) ValidateAll() error {
	return m.validate(true)
}

func (m *StartPlaySession) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if err := m._validateUuid(m.GetGameId()); err != nil {
		err = StartPlaySessionValidationError{
			field:  "GameId",
			reason: "value must be a valid UUID",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetUsername()); l < 3 || l > 50 {
		err := StartPlaySessionValidationError{
			field:  "Username",
			reason: "value length must be between 3 and 50 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_StartPlaySession_Username_Pattern.MatchString(m.GetUsername()) {
		err := StartPlaySessionValidationError{
			field:  "Username",
			reason: "value does not match regex pattern \"^[a-zA-Z0-9_]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetPlayerEnv()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, StartPlaySessionValidationError{
					field:  "PlayerEnv",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, StartPlaySessionValidationError{
					field:  "PlayerEnv",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPlayerEnv()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return StartPlaySessionValidationError{
				field:  "PlayerEnv",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return StartPlaySessionMultiError(errors)
	}

	return nil
}

func (m *StartPlaySession) _validateUuid(uuid string) error {
	if matched := _hub_uuidPattern.MatchString(uuid); !matched {
		return errors.New("invalid uuid format")
	}

	return nil
}

// StartPlaySessionMultiError is an error wrapping multiple validation errors
// returned by StartPlaySession.ValidateAll() if the designated constraints
// aren't met.
type StartPlaySessionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StartPlaySessionMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StartPlaySessionMultiError) AllErrors() []error { return m }

// StartPlaySessionValidationError is the validation error returned by
// StartPlaySession.Validate if the designated constraints aren't met.
type StartPlaySessionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StartPlaySessionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StartPlaySessionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StartPlaySessionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StartPlaySessionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StartPlaySessionValidationError) ErrorName() string { return "StartPlaySessionValidationError" }

// Error satisfies the builtin error interface
func (e StartPlaySessionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStartPlaySession.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StartPlaySessionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StartPlaySessionValidationError{}

var _StartPlaySession_Username_Pattern = regexp.MustCompile("^[a-zA-Z0-9_]+$")

// Validate checks the field values on StopPlaySession with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *StopPlaySession) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StopPlaySession with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// StopPlaySessionMultiError, or nil if none found.
func (m *StopPlaySession) ValidateAll() error {
	return m.validate(true)
}

func (m *StopPlaySession) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SessionId

	// no validation rules for Reason

	if len(errors) > 0 {
		return StopPlaySessionMultiError(errors)
	}

	return nil
}

// StopPlaySessionMultiError is an error wrapping multiple validation errors
// returned by StopPlaySession.ValidateAll() if the designated constraints
// aren't met.
type StopPlaySessionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StopPlaySessionMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StopPlaySessionMultiError) AllErrors() []error { return m }

// StopPlaySessionValidationError is the validation error returned by
// StopPlaySession.Validate if the designated constraints aren't met.
type StopPlaySessionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StopPlaySessionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StopPlaySessionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StopPlaySessionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StopPlaySessionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StopPlaySessionValidationError) ErrorName() string { return "StopPlaySessionValidationError" }

// Error satisfies the builtin error interface
func (e StopPlaySessionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStopPlaySession.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StopPlaySessionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StopPlaySessionValidationError{}

// Validate checks the field values on ErrorMessage with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ErrorMessage) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ErrorMessage with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ErrorMessageMultiError, or
// nil if none found.
func (m *ErrorMessage) ValidateAll() error {
	return m.validate(true)
}

func (m *ErrorMessage) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SessionId

	// no validation rules for ErrorMessage

	// no validation rules for ErrorCode

	// no validation rules for Timestamp

	if len(errors) > 0 {
		return ErrorMessageMultiError(errors)
	}

	return nil
}

// ErrorMessageMultiError is an error wrapping multiple validation errors
// returned by ErrorMessage.ValidateAll() if the designated constraints aren't met.
type ErrorMessageMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ErrorMessageMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ErrorMessageMultiError) AllErrors() []error { return m }

// ErrorMessageValidationError is the validation error returned by
// ErrorMessage.Validate if the designated constraints aren't met.
type ErrorMessageValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ErrorMessageValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ErrorMessageValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ErrorMessageValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ErrorMessageValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ErrorMessageValidationError) ErrorName() string { return "ErrorMessageValidationError" }

// Error satisfies the builtin error interface
func (e ErrorMessageValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sErrorMessage.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ErrorMessageValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ErrorMessageValidationError{}

// Validate checks the field values on StatusMessage with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *StatusMessage) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StatusMessage with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in StatusMessageMultiError, or
// nil if none found.
func (m *StatusMessage) ValidateAll() error {
	return m.validate(true)
}

func (m *StatusMessage) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SessionId

	switch v := m.Status.(type) {
	case *StatusMessage_Error:
		if v == nil {
			err := StatusMessageValidationError{
				field:  "Status",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for Error
	case *StatusMessage_Success:
		if v == nil {
			err := StatusMessageValidationError{
				field:  "Status",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for Success
	case *StatusMessage_Info:
		if v == nil {
			err := StatusMessageValidationError{
				field:  "Status",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for Info
	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return StatusMessageMultiError(errors)
	}

	return nil
}

// StatusMessageMultiError is an error wrapping multiple validation errors
// returned by StatusMessage.ValidateAll() if the designated constraints
// aren't met.
type StatusMessageMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StatusMessageMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StatusMessageMultiError) AllErrors() []error { return m }

// StatusMessageValidationError is the validation error returned by
// StatusMessage.Validate if the designated constraints aren't met.
type StatusMessageValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StatusMessageValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StatusMessageValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StatusMessageValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StatusMessageValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StatusMessageValidationError) ErrorName() string { return "StatusMessageValidationError" }

// Error satisfies the builtin error interface
func (e StatusMessageValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStatusMessage.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StatusMessageValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StatusMessageValidationError{}

// Validate checks the field values on ExchangeMessage with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ExchangeMessage) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExchangeMessage with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ExchangeMessageMultiError, or nil if none found.
func (m *ExchangeMessage) ValidateAll() error {
	return m.validate(true)
}

func (m *ExchangeMessage) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for StationId

	switch v := m.Payload.(type) {
	case *ExchangeMessage_Connect:
		if v == nil {
			err := ExchangeMessageValidationError{
				field:  "Payload",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetConnect()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExchangeMessageValidationError{
						field:  "Connect",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExchangeMessageValidationError{
						field:  "Connect",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetConnect()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExchangeMessageValidationError{
					field:  "Connect",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ExchangeMessage_Games:
		if v == nil {
			err := ExchangeMessageValidationError{
				field:  "Payload",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetGames()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExchangeMessageValidationError{
						field:  "Games",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExchangeMessageValidationError{
						field:  "Games",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetGames()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExchangeMessageValidationError{
					field:  "Games",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ExchangeMessage_Load:
		if v == nil {
			err := ExchangeMessageValidationError{
				field:  "Payload",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetLoad()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExchangeMessageValidationError{
						field:  "Load",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExchangeMessageValidationError{
						field:  "Load",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetLoad()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExchangeMessageValidationError{
					field:  "Load",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ExchangeMessage_Command:
		if v == nil {
			err := ExchangeMessageValidationError{
				field:  "Payload",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetCommand()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExchangeMessageValidationError{
						field:  "Command",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExchangeMessageValidationError{
						field:  "Command",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCommand()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExchangeMessageValidationError{
					field:  "Command",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ExchangeMessage_Status:
		if v == nil {
			err := ExchangeMessageValidationError{
				field:  "Payload",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetStatus()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExchangeMessageValidationError{
						field:  "Status",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExchangeMessageValidationError{
						field:  "Status",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetStatus()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExchangeMessageValidationError{
					field:  "Status",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return ExchangeMessageMultiError(errors)
	}

	return nil
}

// ExchangeMessageMultiError is an error wrapping multiple validation errors
// returned by ExchangeMessage.ValidateAll() if the designated constraints
// aren't met.
type ExchangeMessageMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExchangeMessageMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExchangeMessageMultiError) AllErrors() []error { return m }

// ExchangeMessageValidationError is the validation error returned by
// ExchangeMessage.Validate if the designated constraints aren't met.
type ExchangeMessageValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExchangeMessageValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExchangeMessageValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExchangeMessageValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExchangeMessageValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExchangeMessageValidationError) ErrorName() string { return "ExchangeMessageValidationError" }

// Error satisfies the builtin error interface
func (e ExchangeMessageValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExchangeMessage.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExchangeMessageValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExchangeMessageValidationError{}
